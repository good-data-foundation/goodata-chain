package interfaces

import (
	"bytes"
	context "context"
	"crypto/ecdsa"
	"fmt"
	"log"
	"math/big"
	"sync"
	"testing"
	"time"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
)

const (
	// This privateKey should be replaced to become your local account privateKey.
	// Make sure you have a sufficient balance.
	testPrivKey = "9a01f5c57e377e0239e6036b7b2d700454b760b2dab51390f1eeb2f64fe98b68"
	// The Address generated by `testPrivKey`.
	// Send this address some balance to test
	testAddress = "0x11a449eD8eadAcDA0A290ad0ffEE174fdF0B3f7a"
)

var (
	client     *ethclient.Client
	privateKey *ecdsa.PrivateKey
	GDService  *GoodDataContract
	start      *uint64
	timeout    time.Duration // timeout control timeout of monitoring event.
)

func init() {
	var err error
	// NOTE: watch event needs Web Socket support.
	// Enter console of geth, Input `admin.StartWS("localhost", 8546)` to start listening on 8546 porn.
	client = GetEthWSClient()
	privateKey, err = crypto.HexToECDSA(testPrivKey)
	if err != nil {
		log.Panicf("HexToECDSA err: %s", err)
	}

	GDService, err = NewGoodDataContract(GoodDataSrvAddr, client)
	if err != nil {
		log.Panicf("NewGoodDataContract err: %v", err)
	}

	// i := uint64(0)
	// start = &i
	timeout = 30 * time.Second
}

func TestGDService(t *testing.T) {
	// QSC
	testRegisterQC(t, [][]interface{}{
		{[]byte("111"), []byte("222")},
		{[]byte("dafaex13"), []byte("22dsaex2")},
		{[]byte("adfwsx"), []byte("adxw")},
	})

	testAssignQueryToDOs(t, [][]interface{}{
		{[]byte("111"), []byte("222")},
		{[]byte("dafaex13"), []byte("22dsaex2")},
		{[]byte("adfwsx"), []byte("adxw")},
	})

	testAssignQueryToMPCs(t, [][]interface{}{
		{[]byte("111"), []byte("222")},
		{[]byte("dafaex13"), []byte("22dsaex2")},
		{[]byte("adfwsx"), []byte("adxw")},
	})

	testSubmitQuery(t, [][]interface{}{
		{[]byte("111"), []byte("222"), int64(1), big.NewInt(1)},
		{[]byte("222"), []byte("333"), int64(2), big.NewInt(2)},
		{[]byte("333"), []byte("444"), int64(3), big.NewInt(3)},
	})

	testFinishQueryInOneDO(t, [][]interface{}{
		{[]byte("111"), []byte("111")},
		{[]byte("222"), []byte("222")},
		{[]byte("333"), []byte("333")},
	})

	testFinishQuery(t, [][]interface{}{
		{[]byte("111")},
		{[]byte("222")},
		{[]byte("333")},
	})

	testSubmitPrediction(t, [][]interface{}{
		{[]byte("111"), []byte("222")},
		{[]byte("222"), []byte("333")},
	})

	testFinishPrediction(t, [][]interface{}{
		{[]byte("111"), []byte("222")},
		{[]byte("222")},
	})

	// DSC
	testRegisterDO(t, [][]interface{}{
		{[]byte("111"), []byte("111")},
		{[]byte("222"), []byte("222")},
		{[]byte("333"), []byte("333")},
	})

	// MSC
	testRegisterMPC(t, [][]interface{}{
		{[]byte("111"), []byte("111")},
		{[]byte("222"), []byte("222")},
		{[]byte("333"), []byte("333")},
	})

	// Other
	testAddLog(t, [][]interface{}{
		{[]byte("111"), []byte("111")},
		{[]byte("222"), []byte("222")},
		{[]byte("333"), []byte("333")},
	})
}

func testRegisterQC(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractQCRegistered)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchQCRegistered(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)
		if err != nil {
			t.Fatalf("WatchQCRegistered err: %s", err)
		}

		tx, err := GDService.RegisterQC(getTransactOpts(client, privateKey), arg[0].([]byte), arg[1].([]byte))
		if err != nil {
			t.Fatalf("RegisterQC err: %v", err)
		}
		t.Logf("RegisterQC tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch QCRegistered timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, uuid: %s, publicKey: %s", vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.Uuid), string(vLog.PublicKey)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.Uuid, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, uuid: %x, actual: %x", arg[0].([]byte), vLog.Uuid)
			}
			if bytes.Compare(vLog.PublicKey, arg[1].([]byte)) != 0 {
				t.Fatalf("Expect equal, publicKey: %x, actual: %x", vLog.PublicKey, arg[1].([]byte))
			}
		}
	}
}

func testAssignQueryToDOs(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractDOsOfQuery)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchDOsOfQuery(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)
		if err != nil {
			t.Fatalf("WatchDOsOfQuery err: %s", err)
		}

		tx, err := GDService.AssignQueryToDOs(getTransactOpts(client, privateKey), arg[0].([]byte), arg[1].([]byte))
		if err != nil {
			t.Fatalf("AssignQueryToDOs err: %v", err)
		}
		t.Logf("AssignQueryToDOs tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch DOsOfQuery timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, queryUUID: %s, doUUIDs: %s",
				vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.QueryUUID), string(vLog.DoUUIDs)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.QueryUUID, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, uuid: %x, actual: %x", arg[0].([]byte), vLog.QueryUUID)
			}
			if bytes.Compare(vLog.DoUUIDs, arg[1].([]byte)) != 0 {
				t.Fatalf("Expect equal, DoUUIDs: %x, actual: %x", vLog.DoUUIDs, arg[1].([]byte))
			}
		}
	}
}

func testAssignQueryToMPCs(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractMPCsOfQuery)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchMPCsOfQuery(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)
		if err != nil {
			t.Fatalf("WatchMPCsOfQuery err: %s", err)
		}

		tx, err := GDService.AssignQueryToMPCs(getTransactOpts(client, privateKey), arg[0].([]byte), arg[1].([]byte))
		if err != nil {
			t.Fatalf("AssignQueryToMPCs err: %v", err)
		}
		t.Logf("AssignQueryToMPCs tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch MPCsOfQuery timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, queryUUID: %s, mpcUUIDs: %s",
				vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.QueryUUID), string(vLog.MpcUUIDs)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.QueryUUID, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, queryUUID: %x, actual: %x", arg[0].([]byte), vLog.QueryUUID)
			}
			if bytes.Compare(vLog.MpcUUIDs, arg[1].([]byte)) != 0 {
				t.Fatalf("Expect equal, MpcUUIDs: %x, actual: %x", vLog.MpcUUIDs, arg[1].([]byte))
			}
		}
	}
}

func testSubmitQuery(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractQuerySubmitted)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchQuerySubmitted(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)

		tx, err := GDService.SubmitQuery(getTransactOpts(client, privateKey),
			arg[0].([]byte), arg[1].([]byte), arg[2].(int64), arg[3].(*big.Int))
		if err != nil {
			t.Fatalf("SubmitQuery err: %v", err)
		}
		t.Logf("SubmitQuery tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch querySubmited timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, uuid: %s, qcUUID: %s", vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.QueryUUID), string(vLog.QcUUID)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.QueryUUID, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, uuid: %x, actual: %x", arg[0].([]byte), vLog.QueryUUID)
			}
			if bytes.Compare(vLog.QcUUID, arg[1].([]byte)) != 0 {
				t.Fatalf("Expect equal, qcUUID: %s, actual: %s", string(vLog.QcUUID), string(arg[1].([]byte)))
			}

			if vLog.DataSet != arg[2].(int64) {
				t.Fatalf("Expect equal, dataSet: %d, actual: %d", arg[2].(int64), vLog.DataSet)
			}
		}
	}
}

func testFinishQueryInOneDO(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractQueryFinishedInOneDO)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchQueryFinishedInOneDO(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)
		if err != nil {
			t.Fatalf("WatchQueryFinishedInOneDO err: %s", err)
		}

		tx, err := GDService.FinishQueryInOneDO(getTransactOpts(client, privateKey), arg[0].([]byte), arg[1].([]byte))
		if err != nil {
			t.Fatalf("FinishQueryInOneDO err: %v", err)
		}
		t.Logf("FinishQueryInOneDO tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch QueryFinishedInOneDO timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, uuid: %s", vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.QueryUUID)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.QueryUUID, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, queryUUID: %x, actual: %x", arg[0].([]byte), vLog.QueryUUID)
			}
			if bytes.Compare(vLog.DoUUID, arg[1].([]byte)) != 0 {
				t.Fatalf("Expect equal, doUUID: %x, actual: %x", vLog.DoUUID, arg[1].([]byte))
			}
		}
	}
}

func testFinishQuery(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractQueryFinished)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchQueryFinished(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)
		if err != nil {
			t.Fatalf("WatchQueryFinished err: %s", err)
		}

		tx, err := GDService.FinishQuery(getTransactOpts(client, privateKey), arg[0].([]byte))
		if err != nil {
			t.Fatalf("FinishQuery err: %v", err)
		}
		t.Logf("FinishQuery tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch QueryFinished timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, uuid: %s", vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.QueryUUID)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.QueryUUID, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, queryUUID: %x, actual: %x", arg[0].([]byte), vLog.QueryUUID)
			}
		}
	}
}

func testSubmitPrediction(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractPredictionSubmitted)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchPredictionSubmitted(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)

		tx, err := GDService.SubmitPrediction(getTransactOpts(client, privateKey),
			arg[0].([]byte), arg[1].([]byte))
		if err != nil {
			t.Fatalf("SubmitPrediction err: %v", err)
		}
		t.Logf("SubmitPrediction tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch PredictionSubmited timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, uuid: %s, predictionUUID: %s",
				vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.QueryUUID), string(vLog.PredictionUUID)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.QueryUUID, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, uuid: %x, actual: %x", arg[0].([]byte), vLog.QueryUUID)
			}
			if bytes.Compare(vLog.PredictionUUID, arg[1].([]byte)) != 0 {
				t.Fatalf("Expect equal, PredictionUUID: %s, actual: %s", string(vLog.PredictionUUID), string(arg[1].([]byte)))
			}
		}
	}
}

func testFinishPrediction(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractPredictionFinished)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchPredictionFinished(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)

		tx, err := GDService.FinishPrediction(getTransactOpts(client, privateKey),
			arg[0].([]byte))
		if err != nil {
			t.Fatalf("FinishPrediction err: %v", err)
		}
		t.Logf("FinishPrediction tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch PredictionFinished timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, predictionUUID: %s",
				vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.PredictionUUID)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.PredictionUUID, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, uuid: %x, actual: %x", arg[0].([]byte), vLog.PredictionUUID)
			}
		}
	}
}

func testRegisterDO(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractDORegistered)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchDORegistered(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)
		if err != nil {
			t.Fatalf("WatchDORegistered err: %s", err)
		}

		tx, err := GDService.RegisterDO(getTransactOpts(client, privateKey), arg[0].([]byte), arg[1].([]byte))
		if err != nil {
			t.Fatalf("RegisterDO err: %v", err)
		}
		t.Logf("RegisterDO tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch DORegistered timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, uuid: %s, publicKey: %s", vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.Uuid), string(vLog.PublicKey)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.Uuid, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, uuid: %x, actual: %x", arg[0].([]byte), vLog.Uuid)
			}
			if bytes.Compare(vLog.PublicKey, arg[1].([]byte)) != 0 {
				t.Fatalf("Expect equal, publicKey: %x, actual: %x", vLog.PublicKey, arg[1].([]byte))
			}
		}
	}
}

func testRegisterMPC(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractMPCRegistered)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchMPCRegistered(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)
		if err != nil {
			t.Fatalf("WatchMPCRegistered err: %s", err)
		}

		tx, err := GDService.RegisterMPC(getTransactOpts(client, privateKey), arg[0].([]byte), arg[1].([]byte))
		if err != nil {
			t.Fatalf("RegisterMSC err: %v", err)
		}
		t.Logf("RegisterMSC tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch MPCRegistered timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, uuid: %s, publicKey: %s", vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.Uuid), string(vLog.PublicKey)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.Uuid, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, uuid: %x, actual: %x", arg[0].([]byte), vLog.Uuid)
			}
			if bytes.Compare(vLog.PublicKey, arg[1].([]byte)) != 0 {
				t.Fatalf("Expect equal, publicKey: %x, actual: %x", vLog.PublicKey, arg[1].([]byte))
			}
		}
	}
}

func testAddLog(t *testing.T, args [][]interface{}) {
	for _, arg := range args {
		ch := make(chan *GoodDataContractLogAdded)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()
		sub, err := GDService.WatchLogAdded(&bind.WatchOpts{
			Start:   start,
			Context: ctx,
		}, ch)
		if err != nil {
			t.Fatalf("WatchLogAdded err: %s", err)
		}

		tx, err := GDService.AddLog(getTransactOpts(client, privateKey), arg[0].([]byte), arg[1].([]byte))
		if err != nil {
			t.Fatalf("AddLog err: %v", err)
		}
		t.Logf("AddLog tx: %v\n", tx.Hash().Hex())

		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case <-ctx.Done():
			t.Fatalf("watch LogAdded timeout: %v", ctx.Err())
		case vLog := <-ch:
			t.Logf("receive event, txHash: %s, address: %s, uuid: %s, payload: %s", vLog.Raw.TxHash.Hex(), vLog.Raw.Address.Hex(), string(vLog.Uuid), string(vLog.Payload)) // pointer to event log
			if tx.Hash().Hex() != vLog.Raw.TxHash.Hex() {
				t.Fatalf("Expect equal, txHash: %s, actual: %s", vLog.Raw.TxHash.Hex(), tx.Hash().Hex())
			}
			if bytes.Compare(vLog.Uuid, arg[0].([]byte)) != 0 {
				t.Fatalf("Expect equal, uuid: %x, actual: %x", arg[0].([]byte), vLog.Uuid)
			}
			if bytes.Compare(vLog.Payload, arg[1].([]byte)) != 0 {
				t.Fatalf("Expect equal, payload: %x, actual: %x", vLog.Payload, arg[1].([]byte))
			}
		}
	}
}

func getTransactOpts(client *ethclient.Client, privateKey *ecdsa.PrivateKey) *bind.TransactOpts {
	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		log.Fatalf("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
	}

	fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
	nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
	if err != nil {
		log.Fatalf("pending nonce err: %v", err)
	}

	gasPrice, err := client.SuggestGasPrice(context.Background())
	if err != nil {
		log.Fatalf("suggestGasPrice err: %s", err)
	}

	auth := bind.NewKeyedTransactor(privateKey)
	auth.Nonce = big.NewInt(int64(nonce))
	auth.Value = big.NewInt(0)     // in wei
	auth.GasLimit = uint64(300000) // in units
	auth.GasPrice = gasPrice

	return auth
}

// watchEvents will be listening all event in this contract.
func watchEvents(t *testing.T, wg *sync.WaitGroup) {
	t.Logf("watchEvents is running.")
	query := ethereum.FilterQuery{
		Addresses: []common.Address{GoodDataSrvAddr},
	}
	// NOTE: watch event needs Web Socket support.
	// Enter console of geth, Input `admin.StartWS("localhost", 8546)` to start listening on 8546 porn.
	client := GetEthWSClient()

	logs := make(chan types.Log)
	sub, err := client.SubscribeFilterLogs(context.Background(), query, logs)
	if err != nil {
		t.Fatalf("subscribe filter logs err: %v", err)
	}

	t.Log("subscribe succ")
	for {
		select {
		case err := <-sub.Err():
			t.Fatalf("sub err: %v", err)
		case vLog := <-logs:
			t.Logf("receive event, txHash: %s, address: %s", vLog.TxHash.Hex(), vLog.Address.Hex()) // pointer to event log
			wg.Done()
		}
	}
}

func getAddrFromPrivKey(privKey string) common.Address {
	privateKey, err := crypto.HexToECDSA(privKey)
	if err != nil {
		log.Fatalf("HexToECDSA err: %s", err)
	}
	publicKey := privateKey.Public()
	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
	if !ok {
		log.Fatalf("cannot assert type: publicKey is not of type *ecdsa.PublicKey")
	}

	return crypto.PubkeyToAddress(*publicKeyECDSA)
}

func TestGetAddrFromPrivKey(t *testing.T) {
	addr := getAddrFromPrivKey(testPrivKey)
	fmt.Printf("address: %s\n", addr.Hex()) // address: 0x614CD1D8A1CCe3bb5292557F5498298715F2352f
}
